# this is an include file for cdd.h and cdd_f.h

# pycddlib is a Python wrapper for Komei Fukuda's cddlib
# Copyright (c) 2008-2024, Matthias Troffaes
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

cdef extern from "@cddhdr@" nogil:

    # typedefs
    ###########

    ctypedef int @dd@_boolean
    ctypedef long @dd@_rowrange
    ctypedef long @dd@_colrange
    ctypedef long @dd@_bigrange
    ctypedef set_type @dd@_rowset
    ctypedef set_type @dd@_colset
    ctypedef long *@dd@_rowindex
    ctypedef int *@dd@_rowflag
    ctypedef long *@dd@_colindex
    ctypedef @mytype@ **@dd@_Amatrix
    ctypedef @mytype@ *@dd@_Arow
    ctypedef set_type *@dd@_SetVector
    ctypedef @mytype@ **@dd@_Bmatrix
    ctypedef set_type *@dd@_Aincidence

    # enums
    ########

    ctypedef enum @dd@_AdjacencyTestType:
        @dd@_Combinatorial
        @dd@_Algebraic

    ctypedef enum @dd@_NumberType:
        @dd@_Unknown
        @dd@_Real
        @dd@_Rational
        @dd@_Integer

    ctypedef enum @dd@_RepresentationType:
        @dd@_Unspecified
        @dd@_Inequality
        @dd@_Generator

    ctypedef enum @dd@_RowOrderType:
        @dd@_MaxIndex
        @dd@_MinIndex
        @dd@_MinCutoff
        @dd@_MaxCutoff
        @dd@_MixCutoff
        @dd@_LexMin
        @dd@_LexMax
        @dd@_RandomRow

    # not translated: @dd@_ConversionType, @dd@_IncidenceOutputType, @dd@_AdjacencyOutputType, @dd@_FileInputModeType

    ctypedef enum @dd@_ErrorType:
        @dd@_DimensionTooLarge
        @dd@_ImproperInputFormat
        @dd@_NegativeMatrixSize
        @dd@_EmptyVrepresentation
        @dd@_EmptyHrepresentation
        @dd@_EmptyRepresentation
        @dd@_IFileNotFound
        @dd@_OFileNotOpen
        @dd@_NoLPObjective
        @dd@_NoRealNumberSupport
        @dd@_NotAvailForH
        @dd@_NotAvailForV
        @dd@_CannotHandleLinearity
        @dd@_RowIndexOutOfRange
        @dd@_ColIndexOutOfRange
        @dd@_LPCycling
        @dd@_NumericallyInconsistent
        @dd@_NoError

    ctypedef enum @dd@_CompStatusType:
        @dd@_InProgress
        @dd@_AllFound
        @dd@_RegionEmpty

    ctypedef enum @dd@_LPObjectiveType:
        @dd@_LPnone
        @dd@_LPmax
        @dd@_LPmin

    ctypedef enum @dd@_LPSolverType:
        @dd@_CrissCross
        @dd@_DualSimplex

    ctypedef enum @dd@_LPStatusType:
        @dd@_LPSundecided
        @dd@_Optimal
        @dd@_Inconsistent
        @dd@_DualInconsistent
        @dd@_StrucInconsistent
        @dd@_StrucDualInconsistent
        @dd@_Unbounded
        @dd@_DualUnbounded

    # structures
    #############

    # forward, pointer, and alias declarations
    ctypedef struct @dd@_raydata
    ctypedef @dd@_raydata *@dd@_RayPtr
    ctypedef struct @dd@_adjacencydata
    ctypedef @dd@_adjacencydata *@dd@_AdjacencyPtr
    ctypedef @dd@_adjacencydata @dd@_AdjacencyType
    ctypedef struct @dd@_lpsolution
    ctypedef @dd@_lpsolution *@dd@_LPSolutionPtr
    ctypedef struct @dd@_lpdata
    ctypedef @dd@_lpdata *@dd@_LPPtr
    ctypedef struct @dd@_matrixdata
    ctypedef @dd@_matrixdata *@dd@_MatrixPtr
    ctypedef struct @dd@_setfamily
    ctypedef @dd@_setfamily *@dd@_SetFamilyPtr
    ctypedef struct @dd@_nodedata
    ctypedef @dd@_nodedata *@dd@_NodePtr
    ctypedef struct @dd@_graphdata
    ctypedef @dd@_graphdata *@dd@_GraphPtr
    ctypedef struct @dd@_polyhedradata
    ctypedef @dd@_polyhedradata *@dd@_PolyhedraPtr
    ctypedef struct @dd@_conedata
    ctypedef @dd@_conedata *@dd@_ConePtr

    ctypedef struct @dd@_raydata:
        @mytype@ *Ray
        @dd@_rowset ZeroSet
        @dd@_rowrange FirstInfeasIndex
        @dd@_boolean feasible
        @mytype@ ARay
        @dd@_RayPtr Next

    ctypedef struct @dd@_adjacencydata:
        @dd@_RayPtr Ray1, Ray2
        @dd@_AdjacencyPtr Next

    ctypedef struct @dd@_lpsolution:
        #@dd@_DataFileType filename
        @dd@_LPObjectiveType objective
        @dd@_LPSolverType solver
        @dd@_rowrange m
        @dd@_colrange d
        @dd@_NumberType numbtype
        @dd@_LPStatusType LPS
        @mytype@ optvalue
        @dd@_Arow sol
        @dd@_Arow dsol
        @dd@_colindex nbindex
        @dd@_rowrange re
        @dd@_colrange se
        long pivots[5]
        long total_pivots

    ctypedef struct @dd@_lpdata:
        @dd@_LPObjectiveType objective
        @dd@_LPSolverType solver
        @dd@_boolean Homogeneous
        @dd@_rowrange m
        @dd@_colrange d
        @dd@_Amatrix A
        @dd@_Bmatrix B
        @dd@_rowrange objrow
        @dd@_colrange rhscol
        @dd@_NumberType numbtype
        @dd@_rowrange eqnumber # number of equalities
        @dd@_rowset equalityset
        @dd@_boolean redcheck_extensive
        @dd@_rowrange ired
        @dd@_rowset redset_extra
        @dd@_rowset redset_accum
        @dd@_rowset posset_extra
        @dd@_boolean lexicopivot
        @dd@_LPStatusType LPS
        @dd@_rowrange m_alloc
        @dd@_colrange d_alloc
        @mytype@ optvalue
        @dd@_Arow sol
        @dd@_Arow dsol
        @dd@_colindex nbindex
        @dd@_rowrange re
        @dd@_colrange se
        long pivots[5]
        long total_pivots
        int use_given_basis
        @dd@_colindex given_nbindex
        time_t starttime
        time_t endtime

    ctypedef struct @dd@_matrixdata:
        @dd@_rowrange rowsize
        @dd@_rowset linset
        @dd@_colrange colsize
        @dd@_RepresentationType representation
        @dd@_NumberType numbtype
        @dd@_Amatrix matrix
        @dd@_LPObjectiveType objective
        @dd@_Arow rowvec

    ctypedef struct @dd@_setfamily:
        @dd@_bigrange famsize
        @dd@_bigrange setsize
        @dd@_SetVector set

    ctypedef struct @dd@_nodedata:
        @dd@_bigrange key
        @dd@_NodePtr next

    ctypedef struct @dd@_graphdata:
        @dd@_bigrange vsize
        @dd@_NodePtr *adjlist

    ctypedef struct @dd@_polyhedradata:
        @dd@_RepresentationType representation
        @dd@_boolean homogeneous
        @dd@_colrange d
        @dd@_rowrange m
        @dd@_Amatrix A
        @dd@_NumberType numbtype
        @dd@_ConePtr child
        @dd@_rowrange m_alloc
        @dd@_colrange d_alloc
        @dd@_Arow c
        @dd@_rowflag EqualityIndex
        @dd@_boolean IsEmpty
        @dd@_boolean NondegAssumed
        @dd@_boolean InitBasisAtBottom
        @dd@_boolean RestrictedEnumeration
        @dd@_boolean RelaxedEnumeration
        @dd@_rowrange m1
        @dd@_boolean AincGenerated
        @dd@_colrange ldim
        @dd@_bigrange n
        @dd@_Aincidence Ainc
        @dd@_rowset Ared
        @dd@_rowset Adom

    ctypedef struct @dd@_conedata:
        @dd@_RepresentationType representation
        @dd@_rowrange m
        @dd@_colrange d
        @dd@_Amatrix A
        @dd@_NumberType numbtype
        @dd@_PolyhedraPtr parent
        @dd@_rowrange m_alloc
        @dd@_colrange d_alloc
        @dd@_rowrange Iteration
        @dd@_RowOrderType HalfspaceOrder
        @dd@_RayPtr FirstRay, LastRay, ArtificialRay
        @dd@_RayPtr PosHead, ZeroHead, NegHead, PosLast, ZeroLast, NegLast
        @dd@_AdjacencyType **Edges
        unsigned int rseed
        @dd@_boolean ColReduced
        @dd@_bigrange LinearityDim 
        @dd@_colrange d_orig
        @dd@_colindex newcol
        @dd@_colindex InitialRayIndex
        @dd@_rowindex OrderVector
        @dd@_boolean RecomputeRowOrder
        @dd@_boolean PreOrderedRun
        @dd@_rowset GroundSet, EqualitySet, NonequalitySet, AddedHalfspaces, WeaklyAddedHalfspaces, InitialHalfspaces
        long RayCount, FeasibleRayCount, WeaklyFeasibleRayCount, TotalRayCount, ZeroRayCount
        long EdgeCount, TotalEdgeCount
        long count_int, count_int_good, count_int_bad
        @dd@_Bmatrix B
        @dd@_Bmatrix Bsave
        @dd@_ErrorType Error
        @dd@_CompStatusType CompStatus
        time_t starttime, endtime

    # functions
    ############

    # not everything is defined here, just most common operations
    # add more as needed...

    cdef void @dd@_set_d(@mytype@, double)
    cdef void @dd@_set_si(@mytype@, signed long int)
    cdef void @dd@_set_si2(@mytype@, signed long int, unsigned long int)
    cdef double @dd@_get_d(@mytype@)

    cdef void @dd@_set_global_constants()
    cdef void @dd@_free_global_constants()

    cdef void @dd@_WriteErrorMessages(libc.stdio.FILE *, @dd@_ErrorType)

    cdef void @dd@_InitializeArow(@dd@_colrange,@dd@_Arow *)
    cdef void @dd@_InitializeAmatrix(@dd@_rowrange,@dd@_colrange,@dd@_Amatrix *)
    cdef void @dd@_InitializeBmatrix(@dd@_colrange, @dd@_Bmatrix *)
    cdef @dd@_SetFamilyPtr @dd@_CreateSetFamily(@dd@_bigrange,@dd@_bigrange)
    cdef void @dd@_FreeSetFamily(@dd@_SetFamilyPtr)
    cdef @dd@_MatrixPtr @dd@_CreateMatrix(@dd@_rowrange,@dd@_colrange)
    cdef void @dd@_FreeAmatrix(@dd@_rowrange,@dd@_colrange,@dd@_Amatrix)
    cdef void @dd@_FreeArow(@dd@_colrange, @dd@_Arow)
    cdef void @dd@_FreeBmatrix(@dd@_colrange,@dd@_Bmatrix)
    cdef void @dd@_FreeDDMemory(@dd@_PolyhedraPtr)
    cdef void @dd@_FreePolyhedra(@dd@_PolyhedraPtr)
    cdef void @dd@_FreeMatrix(@dd@_MatrixPtr)
    cdef void @dd@_SetToIdentity(@dd@_colrange, @dd@_Bmatrix)

    cdef @dd@_MatrixPtr @dd@_CopyInput(@dd@_PolyhedraPtr)
    cdef @dd@_MatrixPtr @dd@_CopyOutput(@dd@_PolyhedraPtr)
    cdef @dd@_MatrixPtr @dd@_CopyInequalities(@dd@_PolyhedraPtr)
    cdef @dd@_MatrixPtr @dd@_CopyGenerators(@dd@_PolyhedraPtr)
    cdef @dd@_SetFamilyPtr @dd@_CopyIncidence(@dd@_PolyhedraPtr)
    cdef @dd@_SetFamilyPtr @dd@_CopyAdjacency(@dd@_PolyhedraPtr)
    cdef @dd@_SetFamilyPtr @dd@_CopyInputIncidence(@dd@_PolyhedraPtr)
    cdef @dd@_SetFamilyPtr @dd@_CopyInputAdjacency(@dd@_PolyhedraPtr)
    cdef @dd@_boolean @dd@_DDFile2File(char *ifile, char *ofile, @dd@_ErrorType *err)
    cdef @dd@_boolean @dd@_DDInputAppend(@dd@_PolyhedraPtr*, @dd@_MatrixPtr, @dd@_ErrorType*)
    cdef @dd@_MatrixPtr @dd@_PolyFile2Matrix(libc.stdio.FILE *f, @dd@_ErrorType *)
    
    cdef @dd@_PolyhedraPtr @dd@_DDMatrix2Poly(@dd@_MatrixPtr, @dd@_ErrorType *)
    cdef @dd@_PolyhedraPtr @dd@_DDMatrix2Poly2(@dd@_MatrixPtr, @dd@_RowOrderType, @dd@_ErrorType *)
    cdef @dd@_boolean @dd@_Redundant(@dd@_MatrixPtr, @dd@_rowrange, @dd@_Arow, @dd@_ErrorType *)
    cdef @dd@_rowset @dd@_RedundantRows(@dd@_MatrixPtr, @dd@_ErrorType *)
    cdef @dd@_boolean @dd@_SRedundant(@dd@_MatrixPtr, @dd@_rowrange, @dd@_Arow, @dd@_ErrorType *)
    cdef @dd@_rowset @dd@_SRedundantRows(@dd@_MatrixPtr, @dd@_ErrorType *)
    cdef @dd@_rowset @dd@_RedundantRowsViaShooting(@dd@_MatrixPtr, @dd@_ErrorType *)
    cdef @dd@_rowrange @dd@_RayShooting(@dd@_MatrixPtr, @dd@_Arow intpt, @dd@_Arow direction)
    cdef @dd@_boolean @dd@_ImplicitLinearity(@dd@_MatrixPtr, @dd@_rowrange, @dd@_Arow, @dd@_ErrorType *)
    cdef @dd@_rowset @dd@_ImplicitLinearityRows(@dd@_MatrixPtr, @dd@_ErrorType *)
    cdef int @dd@_FreeOfImplicitLinearity(@dd@_MatrixPtr, @dd@_Arow, @dd@_rowset *, @dd@_ErrorType *)
    cdef @dd@_boolean @dd@_MatrixCanonicalizeLinearity(@dd@_MatrixPtr *, @dd@_rowset *,@dd@_rowindex *, @dd@_ErrorType *)
    cdef @dd@_boolean @dd@_MatrixCanonicalize(@dd@_MatrixPtr *, @dd@_rowset *, @dd@_rowset *, @dd@_rowindex *, @dd@_ErrorType *)
    cdef @dd@_boolean @dd@_MatrixRedundancyRemove(@dd@_MatrixPtr *M, @dd@_rowset *redset,@dd@_rowindex *newpos, @dd@_ErrorType *)
    cdef @dd@_boolean @dd@_FindRelativeInterior(@dd@_MatrixPtr, @dd@_rowset *, @dd@_rowset *, @dd@_LPSolutionPtr *, @dd@_ErrorType *)
    cdef @dd@_boolean @dd@_ExistsRestrictedFace(@dd@_MatrixPtr, @dd@_rowset, @dd@_rowset, @dd@_ErrorType *)
    cdef @dd@_boolean @dd@_ExistsRestrictedFace2(@dd@_MatrixPtr, @dd@_rowset, @dd@_rowset, @dd@_LPSolutionPtr *, @dd@_ErrorType *)
    
    cdef @dd@_SetFamilyPtr @dd@_Matrix2Adjacency(@dd@_MatrixPtr, @dd@_ErrorType *)
    cdef @dd@_SetFamilyPtr @dd@_Matrix2WeakAdjacency(@dd@_MatrixPtr, @dd@_ErrorType *)
    cdef long @dd@_MatrixRank(@dd@_MatrixPtr, @dd@_rowset, @dd@_colset, @dd@_rowset *, @dd@_colset *)

    cdef @dd@_MatrixPtr @dd@_CopyMatrix(@dd@_MatrixPtr)
    cdef int @dd@_MatrixAppendTo(@dd@_MatrixPtr*, @dd@_MatrixPtr)
    cdef int @dd@_MatrixRowRemove(@dd@_MatrixPtr *M, @dd@_rowrange r)

    cdef void @dd@_WriteAmatrix(libc.stdio.FILE *, @dd@_Amatrix, @dd@_rowrange, @dd@_colrange)
    cdef void @dd@_WriteArow(libc.stdio.FILE *f, @dd@_Arow a, @dd@_colrange)
    cdef void @dd@_WriteBmatrix(libc.stdio.FILE *, @dd@_colrange, @dd@_Bmatrix T)
    cdef void @dd@_WriteMatrix(libc.stdio.FILE *, @dd@_MatrixPtr)
    cdef void @dd@_MatrixIntegerFilter(@dd@_MatrixPtr)
    cdef void @dd@_WriteReal(libc.stdio.FILE *, @mytype@)
    cdef void @dd@_WriteNumber(libc.stdio.FILE *f, @mytype@ x)
    cdef void @dd@_WritePolyFile(libc.stdio.FILE *, @dd@_PolyhedraPtr)
    cdef void @dd@_WriteRunningMode(libc.stdio.FILE *, @dd@_PolyhedraPtr)
    cdef void @dd@_WriteErrorMessages(libc.stdio.FILE *, @dd@_ErrorType)
    cdef void @dd@_WriteSetFamily(libc.stdio.FILE *, @dd@_SetFamilyPtr)
    cdef void @dd@_WriteSetFamilyCompressed(libc.stdio.FILE *, @dd@_SetFamilyPtr)
    cdef void @dd@_WriteProgramDescription(libc.stdio.FILE *)
    cdef void @dd@_WriteDDTimes(libc.stdio.FILE *, @dd@_PolyhedraPtr)
    cdef void @dd@_WriteTimes(libc.stdio.FILE *, time_t, time_t)
    cdef void @dd@_WriteIncidence(libc.stdio.FILE *, @dd@_PolyhedraPtr)
    cdef void @dd@_WriteAdjacency(libc.stdio.FILE *, @dd@_PolyhedraPtr)
    cdef void @dd@_WriteInputAdjacency(libc.stdio.FILE *, @dd@_PolyhedraPtr)
    cdef void @dd@_WriteInputIncidence(libc.stdio.FILE *, @dd@_PolyhedraPtr)

    cdef @dd@_LPPtr @dd@_Matrix2LP(@dd@_MatrixPtr, @dd@_ErrorType *)
    cdef @dd@_boolean @dd@_LPSolve(@dd@_LPPtr, @dd@_LPSolverType, @dd@_ErrorType *)
    cdef void @dd@_FreeLPData(@dd@_LPPtr)
    cdef void @dd@_WriteLP(libc.stdio.FILE *f, @dd@_LPPtr lp)
    cdef void @dd@_WriteLPResult(libc.stdio.FILE *f, @dd@_LPPtr lp, @dd@_ErrorType err)

# helper functions

### begin windows hack (broken libc.stdio.tmpfile)
cdef extern from *:
     cdef void _emit_ifdef_msc_ver "#ifdef _MSC_VER //" ()
     cdef void _emit_else "#else //" ()
     cdef void _emit_endif "#endif //" ()
cdef extern from "stdio.h":
    char *_tempnam(char *dir, char *prefix)
cdef libc.stdio.FILE *libc_stdio_tmpfile() except NULL:
     cdef libc.stdio.FILE *result
     cdef char *name
     _emit_ifdef_msc_ver()
     name = _tempnam(NULL, NULL)
     if name == NULL:
         raise RuntimeError("failed to create temporary file name")
     result = libc.stdio.fopen(name, "wb+TD");
     libc.stdlib.free(name)
     _emit_else()
     result = libc.stdio.tmpfile()
     _emit_endif()
     return result
### end windows hack (broken libc.stdio.tmpfile)

cdef libc.stdio.FILE *_tmpfile() except NULL:
     cdef libc.stdio.FILE *result
     # libc.stdio.tmpfile() is broken on windows
     result = libc_stdio_tmpfile()
     if result == NULL:
         raise RuntimeError("failed to create temporary file")
     return result

cdef _tmpread(libc.stdio.FILE *pfile):
    cdef size_t length
    cdef size_t num_bytes
    cdef void *buffer
    result = ""
    libc.stdio.fseek(pfile, 0, libc.stdio.SEEK_END)
    length = libc.stdio.ftell(pfile)
    buffer = cpython.mem.PyMem_RawMalloc(length)
    try:
        libc.stdio.fseek(pfile, 0, libc.stdio.SEEK_SET)
        num_bytes = libc.stdio.fread(buffer, 1, length, pfile)
        result = cpython.unicode.PyUnicode_DecodeUTF8(<char*>buffer, num_bytes, 'strict')
    finally:
        libc.stdio.fclose(pfile)
        cpython.mem.PyMem_RawFree(buffer)
    return result

cdef _get_set(set_type set_):
    """Create Python set from given set_type."""
    cdef unsigned long elem
    return {elem
            for elem from 0 <= elem < set_[0]
            if set_member(elem + 1, set_)}

cdef _set_set(set_type set_, pset):
    """Set elements of set_type by elements from Python set."""
    cdef unsigned long elem
    for elem from 0 <= elem < set_[0]:
        if elem in pset:
            set_addelem(set_, elem + 1)
        else:
            set_delelem(set_, elem + 1)

cdef _get_dd_setfam(@dd@_SetFamilyPtr setfam):
    """Create list of Python sets from dd_SetFamilyPtr, and
    free the pointer. The indexing of the sets start at 0, unlike the
    string output from cddlib, which starts at 1.
    """
    cdef long elem
    if setfam == NULL:
        raise ValueError("failed to get set family")
    result = [{elem
               for elem from 0 <= elem < setfam.setsize
               if set_member(elem + 1, setfam.set[i])}
              for i in range(setfam.famsize)]
    @dd@_FreeSetFamily(setfam)
    return result

cdef _raise_error(@dd@_ErrorType error, msg):
    """Convert error into string and raise it."""
    cdef libc.stdio.FILE *pfile
    pfile = _tmpfile()
    @dd@_WriteErrorMessages(pfile, error)
    raise RuntimeError(msg + "\n" + _tmpread(pfile).rstrip('\n'))

cdef _make_dd_matrix(@dd@_MatrixPtr dd_mat):
    """Create matrix from given pointer."""
    # we must "cdef Matrix mat" because otherwise pyrex will not
    # recognize mat.thisptr as a C pointer
    cdef Matrix mat
    if dd_mat == NULL:
        raise ValueError("failed to make matrix")
    mat = Matrix([[]])
    @dd@_FreeMatrix(mat.dd_mat)
    mat.dd_mat = dd_mat
    return mat

# extension classes to wrap matrix, linear program, and polyhedron

cdef class Matrix:

    cdef @dd@_MatrixPtr dd_mat

    property row_size:
        def __get__(self):
            return self.dd_mat.rowsize

    def __len__(self):
        return self.dd_mat.rowsize


    property col_size:
        def __get__(self):
            return self.dd_mat.colsize

    property lin_set:
        def __get__(self):
            return _get_set(self.dd_mat.linset)
        def __set__(self, value):
            _set_set(self.dd_mat.linset, value)

    property rep_type:
        def __get__(self):
            return self.dd_mat.representation
        def __set__(self, @dd@_RepresentationType value):
            self.dd_mat.representation = value

    property obj_type:
        def __get__(self):
            return self.dd_mat.objective
        def __set__(self, @dd@_LPObjectiveType value):
            self.@dd@_mat.objective = value

    property obj_func:
        def __get__(self):
            # return an immutable tuple to prohibit item assignment
            cdef int colindex
            return tuple([@dd@_get_d(self.dd_mat.rowvec[colindex])
                          for 0 <= colindex < self.dd_mat.colsize])
        def __set__(self, obj_func):
            cdef int colindex
            if len(obj_func) != self.dd_mat.colsize:
                raise ValueError(
                    "objective function does not match matrix column size")
            for colindex, value in enumerate(obj_func):
                _set_mytype(self.dd_mat.rowvec[colindex], value)

    def __str__(self):
        cdef libc.stdio.FILE *pfile
        pfile = _tmpfile()
        @dd@_WriteMatrix(pfile, self.dd_mat)
        return _tmpread(pfile).rstrip('\n')

    def __init__(self, *args, **kwargs):
        # overriding this to prevent base class constructor to be called
        pass

    def __cinit__(self, rows, linear=False):
        """Load matrix data from the rows (which is a list of lists)."""
        cdef Py_ssize_t numrows, numcols, rowindex, colindex
        # reset pointers
        self.dd_mat = NULL
        # determine dimension
        numrows = len(rows)
        if numrows > 0:
            numcols = len(rows[0])
        else:
            numcols = 0
        # create new matrix, safely casting ranges
        cdef @dd@_rowrange numrows2 = <@dd@_rowrange>numrows
        cdef @dd@_colrange numcols2 = <@dd@_colrange>numcols
        if numrows2 != numrows or numcols2 != numcols:
            raise ValueError("matrix too large")
        self.dd_mat = @dd@_CreateMatrix(numrows2, numcols2)
        # load data
        for rowindex, row in enumerate(rows):
            if len(row) != numcols:
                raise ValueError("rows have different lengths")
            for colindex, value in enumerate(row):
                _set_mytype(self.dd_mat.matrix[rowindex][colindex], value)
        if linear:
            # set all constraints as linear
            set_compl(self.dd_mat.linset, self.dd_mat.linset)
        # debug
        #@dd@_WriteMatrix(stdout, self.dd_mat)

    def __dealloc__(self):
        """Deallocate matrix."""
        @dd@_FreeMatrix(self.dd_mat)
        self.dd_mat = NULL

    def copy(self):
        return _make_dd_matrix(@dd@_CopyMatrix(self.dd_mat))

    def extend(self, rows, linear=False):
        cdef Matrix other
        cdef int success
        # create matrix with given rows
        other = Matrix(rows, linear=linear)
        # call @dd@_AppendToMatrix
        success = @dd@_MatrixAppendTo(&self.dd_mat, other.dd_mat)
        # check result
        if success != 1:
            raise ValueError("cannot append because column sizes differ")

    def __getitem__(self, key):
        cdef @dd@_rowrange rownum
        cdef @dd@_rowrange j
        # check if we are slicing
        if isinstance(key, slice):
            indices = key.indices(len(self))
            # XXX once generators are supported in cython, this should
            # return (self.__getitem__(i) for i in xrange(*indices))
            return tuple([self.__getitem__(i) for i in xrange(*indices)])
        else:
            rownum = key
            if rownum < 0 or rownum >= self.dd_mat.rowsize:
                raise IndexError("row index out of range")
            # return an immutable tuple to prohibit item assignment
            return tuple([_get_mytype(self.dd_mat.matrix[rownum][j])
                          for 0 <= j < self.dd_mat.colsize])

    def canonicalize(self):
        cdef @dd@_rowset impl_linset
        cdef @dd@_rowset redset
        cdef @dd@_rowindex newpos
        cdef @dd@_ErrorType error = @dd@_NoError
        cdef int m
        cdef @dd@_boolean success
        if self.rep_type == @dd@_Unspecified:
            raise ValueError("rep_type unspecified")
        m = self.dd_mat.rowsize
        success = @dd@_MatrixCanonicalize(&self.dd_mat, &impl_linset, &redset, &newpos, &error)
        result = (_get_set(impl_linset), _get_set(redset))
        set_free(impl_linset)
        set_free(redset)
        libc.stdlib.free(newpos)
        if not success or error != @dd@_NoError:
            _raise_error(error, "failed to canonicalize matrix")
        return result

cdef class LinProg:

    cdef @dd@_LPPtr dd_lp

    property solver:
        def __get__(self):
            return self.dd_lp.solver

    property obj_type:
        def __get__(self):
            return self.dd_lp.objective
        def __set__(self, @dd@_LPObjectiveType value):
            self.dd_lp.objective = value

    property status:
        def __get__(self):
            return self.dd_lp.LPS

    property obj_value:
        def __get__(self):
            return _get_mytype(self.dd_lp.optvalue)

    property primal_solution:
        def __get__(self):
            cdef int colindex
            return tuple([_get_mytype(self.dd_lp.sol[colindex])
                          for 1 <= colindex < self.dd_lp.d])

    property dual_solution:
        def __get__(self):
            cdef int colindex
            return tuple([_get_mytype(self.dd_lp.dsol[colindex])
                          for 1 <= colindex < self.dd_lp.d])

    def __str__(self):
        """Print the linear program data."""
        cdef libc.stdio.FILE *pfile
        # open file for writing the data
        pfile = _tmpfile()
        # note: if lp has an error, then exception is raised
        # so pass @dd@_NoError
        @dd@_WriteLPResult(pfile, self.dd_lp, @dd@_NoError)
        return _tmpread(pfile).rstrip('\n')

    def __init__(self, *args, **kwargs):
        # overriding this to prevent base class constructor to be called
        pass

    def __cinit__(self, Matrix mat):
        """Initialize linear program solution from solved linear program in
        the given matrix.
        """
        cdef @dd@_ErrorType error = @dd@_NoError
        self.dd_lp = NULL
        # read matrix
        self.dd_lp = @dd@_Matrix2LP(mat.dd_mat, &error)
        if self.dd_lp == NULL or error != @dd@_NoError:
            if self.dd_lp != NULL:
                @dd@_FreeLPData(self.dd_lp)
            _raise_error(error, "failed to load linear program")
        # debug
        #@dd@_WriteLP(stdout, self.dd_lp)

    def __dealloc__(self):
        """Deallocate solution memory."""
        @dd@_FreeLPData(self.dd_lp)
        self.dd_lp = NULL

    def solve(self, @dd@_LPSolverType solver=@dd@_DualSimplex):
        cdef @dd@_ErrorType error = @dd@_NoError
        @dd@_LPSolve(self.dd_lp, solver, &error)
        if error != @dd@_NoError:
            _raise_error(error, "failed to solve linear program")

cdef class Polyhedron:

    cdef @dd@_PolyhedraPtr dd_poly

    property rep_type:
        def __get__(self):
            return self.dd_poly.representation

        def __set__(self, @dd@_RepresentationType value):
            self.dd_poly.representation = value

    def __str__(self):
        """Print the polyhedra data."""
        cdef libc.stdio.FILE *pfile
        pfile = _tmpfile()
        @dd@_WritePolyFile(pfile, self.dd_poly)
        return _tmpread(pfile).rstrip('\n')

    def __init__(self, *args, **kwargs):
        # overriding this to prevent base class constructor to be called
        pass

    def __cinit__(self, Matrix mat):
        """Initialize polyhedra from given matrix."""
        cdef @dd@_ErrorType error = @dd@_NoError
        # initialize pointers
        self.dd_poly = NULL
        # read matrix
        self.dd_poly = @dd@_DDMatrix2Poly(mat.dd_mat, &error)
        if self.dd_poly == NULL or error != @dd@_NoError:
            # Do not clean up data: see issue #7.
            #if self.dd_poly != NULL:
            #    @dd@_FreePolyhedra(self.dd_poly)
            _raise_error(error, "failed to load polyhedra")
        # debug
        #dd_WritePolyFile(stdout, self.@dd@_poly)

    def __dealloc__(self):
        """Deallocate matrix."""
        if self.dd_poly:
            @dd@_FreePolyhedra(self.dd_poly)
        self.dd_poly = NULL

    def get_inequalities(self):
        return _make_dd_matrix(@dd@_CopyInequalities(self.dd_poly))

    def get_generators(self):
        return _make_dd_matrix(@dd@_CopyGenerators(self.dd_poly))

    def get_adjacency(self):
        return _get_dd_setfam(@dd@_CopyAdjacency(self.dd_poly))

    def get_input_adjacency(self):
        return _get_dd_setfam(@dd@_CopyInputAdjacency(self.dd_poly))

    def get_incidence(self):
        return _get_dd_setfam(@dd@_CopyIncidence(self.dd_poly))

    def get_input_incidence(self):
        return _get_dd_setfam(@dd@_CopyInputIncidence(self.dd_poly))

# module initialization code comes here
# initialize module constants
@dd@_set_global_constants()

# should call @dd@_free_global_constants() when module is destroyed
# how does python do that?? let's not bother for now...

from collections.abc import Sequence, Set, Container, Iterable
from fractions import Fraction
from typing import Union, Optional

from cdd import LPObjType, LPSolverType, LPStatusType, RepType

class Matrix:
    @property
    def shape(self) -> tuple[int, int]: ...
    @property
    def array(self) -> Sequence[Sequence[Fraction]]: ...
    @property
    def lin_set(self) ->  Set[int]: ...
    @property
    def obj_func(self) ->  Sequence[Fraction]: ...
    @property
    def obj_type(self) ->  LPObjType: ...
    @property
    def rep_type(self) ->  RepType: ...

def matrix_from_array(
    array: Sequence[Sequence[Union[Fraction, int]]],
    lin_set: Container[int] = (),
    rep_type: RepType = RepType.UNSPECIFIED,
    obj_type: LPObjType = LPObjType.NONE,
    obj_func: Optional[Sequence[Union[Fraction, int]]] = None,
) -> Matrix: ...
def matrix_append_to(matrix1: Matrix, matrix2: Matrix) -> None: ...
def matrix_canonicalize(matrix: Matrix) -> None: ...
def matrix_copy(matrix: Matrix) -> Matrix: ...

class LinProg:
    obj_type: LPObjType

    @property
    def dual_solution(self) -> Sequence[Fraction]: ...
    @property
    def obj_value(self) -> Fraction: ...
    @property
    def primal_solution(self) -> Sequence[Fraction]: ...
    @property
    def status(self) -> LPStatusType: ...
    @property
    def solver(self) -> LPSolverType: ...
    def __init__(self, mat: Matrix) -> None: ...
    def solve(self, solver: LPSolverType = LPSolverType.DUAL_SIMPLEX) -> None: ...

class Polyhedron:
    @property
    def rep_type(self) -> RepType: ...
    def __init__(self, mat: Matrix) -> None: ...
    def get_generators(self) -> Matrix: ...
    def get_inequalities(self) -> Matrix: ...
    def get_adjacency(self) -> Sequence[Set[int]]: ...
    def get_incidence(self) -> Sequence[Set[int]]: ...
    def get_input_adjacency(self) -> Sequence[Set[int]]: ...
    def get_input_incidence(self) -> Sequence[Set[int]]: ...

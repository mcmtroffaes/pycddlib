from collections.abc import Sequence, Set, Container, Iterable
from enum import IntFlag
from typing import ClassVar, SupportsFloat, Optional

class LPObjType(IntFlag):
    MAX: ClassVar[LPObjType] = ...
    MIN: ClassVar[LPObjType] = ...
    NONE: ClassVar[LPObjType] = ...

class LPSolverType(IntFlag):
    CRISS_CROSS: ClassVar[LPSolverType] = ...
    DUAL_SIMPLEX: ClassVar[LPSolverType] = ...

class LPStatusType(IntFlag):
    DUAL_INCONSISTENT: ClassVar[LPStatusType] = ...
    DUAL_UNBOUNDED: ClassVar[LPStatusType] = ...
    INCONSISTENT: ClassVar[LPStatusType] = ...
    OPTIMAL: ClassVar[LPStatusType] = ...
    STRUC_DUAL_INCONSISTENT: ClassVar[LPStatusType] = ...
    STRUC_INCONSISTENT: ClassVar[LPStatusType] = ...
    UNBOUNDED: ClassVar[LPStatusType] = ...
    UNDECIDED: ClassVar[LPStatusType] = ...

class RepType(IntFlag):
    GENERATOR: ClassVar[RepType] = ...
    INEQUALITY: ClassVar[RepType] = ...
    UNSPECIFIED: ClassVar[RepType] = ...

class Matrix:
    @property
    def shape(self) -> tuple[int, int]: ...
    @property
    def array(self) -> Sequence[Sequence[float]]: ...
    @property
    def lin_set(self) ->  Set[int]: ...
    @lin_set.setter
    def lin_set(self, value: Container[int]) -> None: ...
    @property
    def obj_func(self) ->  Sequence[float]: ...
    @obj_func.setter
    def obj_func(self, value: Sequence[float]) -> None: ...
    @property
    def obj_type(self) ->  LPObjType: ...
    @obj_type.setter
    def obj_type(self, value: LPObjType) ->  None: ...
    @property
    def rep_type(self) ->  RepType: ...
    @rep_type.setter
    def rep_type(self, value: RepType) ->  None: ...

def matrix_from_array(
    array: Sequence[Sequence[SupportsFloat]],
    lin_set: Container[int] = (),
    rep_type: RepType = RepType.UNSPECIFIED,
    obj_type: LPObjType = LPObjType.NONE,
    obj_func: Optional[Sequence[SupportsFloat]] = None,
) -> Matrix: ...
def matrix_append_to(matrix1: Matrix, matrix2: Matrix) -> None: ...
def matrix_canonicalize(matrix: Matrix) -> None: ...
def matrix_copy(matrix: Matrix) -> Matrix: ...

class LinProg:
    obj_type: LPObjType

    @property
    def dual_solution(self) -> Sequence[float]: ...
    @property
    def obj_value(self) -> float: ...
    @property
    def primal_solution(self) -> Sequence[float]: ...
    @property
    def status(self) -> LPStatusType: ...
    @property
    def solver(self) -> LPSolverType: ...
    def __init__(self, mat: Matrix) -> None: ...
    def solve(self, solver: LPSolverType = LPSolverType.DUAL_SIMPLEX) -> None: ...

class Polyhedron:
    @property
    def rep_type(self) -> RepType: ...
    def __init__(self, mat: Matrix) -> None: ...
    def get_generators(self) -> Matrix: ...
    def get_inequalities(self) -> Matrix: ...
    def get_adjacency(self) -> Sequence[Set[int]]: ...
    def get_incidence(self) -> Sequence[Set[int]]: ...
    def get_input_adjacency(self) -> Sequence[Set[int]]: ...
    def get_input_incidence(self) -> Sequence[Set[int]]: ...
